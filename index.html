<!DOCTYPE html>
<html lang='en'>

  <head>
    <title>Bugs Game</title>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <link rel='stylesheet' href='styles.css' />
  </head>

  <body>

    <div id='wrapper'>
      <div id='instructions'>
        <p>Gameplay Instructions</p>
        <br>
        <p>First player to get all 5 pieces to the opposite side of the board wins!</p>
      </div>

      <div id='gameArea'>
        <div id='grid'></div>
      </div>

      <div id='results'>
        <p>Game Stats</p>
        <br><br>
        <span>Active player: </span><span id='activePlayer'></span>
        <br><br>
        <span>Remaining moves: </span><span id='moves'></span>
        <br><br><br><br>
        <span>Player 1 points: </span><span id='p1Points'>0</span>
        <br><br>
        <span>Player 2 points: </span><span id='p2Points'>0</span>
        <!-- <div id='restart' onclick=resetGame()>play again</div> -->
      </div>
    </div>

    <script>

      const grid = document.getElementById('grid');
      const rows = 5;
      const cols = 13;
      const cells = rows * cols;
      // const cellWidth = Math.round((60 / cols) * 10) / 10 + 'vw';
      const homeCells = [];
      for (i = 0; i < rows; i++) { //player 1
        homeCells.push(cols * i);
      }
      for (i = 0; i < rows; i++) { //player 2
        homeCells.push(cols * i + (cols - 1));
      }
      const firstCols = []; //for indeces of first column of cell grid
      for (i = 0; i < rows; i++) {
        firstCols.push(homeCells[i]);
      }
      const cellTypes = {
        covid19: ['home', 'people', 'vaccine', 'mask', 'wash', 'crowds', 'switch', 'fever', 'cough', 'fatigue', 'rest', 'virus', 'home'],
        malaria: ['home', 'bite', 'medication', 'nets', 'spray', 'clothes', 'switch', 'fever', 'vomit', 'fatigue', 'medication', 'microbe', 'home'],
        dengue: ['home', 'bite', 'vaccine', 'nets', 'spray', 'clothes', 'switch', 'fever', 'vomit', 'aches', 'rest', 'virus', 'home'],
        bilharzia: ['home', 'water', 'medication', 'boil', 'avoid', 'cook', 'switch', 'blood', 'skin', 'aches', 'medication', 'parasite', 'home'],
        chagas: ['home', 'bite', 'clean', '?', 'spray', 'insect', 'switch', 'fever', 'vomit', 'aches', 'medication', 'microbe', 'home']
      };
      let bugs = Object.keys(cellTypes);
      //get a single array with unique cell types
      const allCellTypes = [];
      for (i = 0; i < rows; i++) {
        cellTypes[bugs[i]].map(e => allCellTypes.push(e));
      }
      const uniqueCellTypes = [...new Set(allCellTypes)];
      //randomise order of rows/bugs (so layout of board is different for each game)
      function shuffle(array) {
        let tmp, current;
        let top = rows - 1;
        while (top > 0) {
          current = Math.floor(Math.random() * (top + 1));
          tmp = array[current];
          array[current] = array[top];
          array[top] = tmp;
          --top;
        }
        return array;
      }
      bugs = shuffle(bugs);
      let occupiedCells = [...homeCells];
      // const allowedMoves = { //if total number of colums = 10
      //   p1: [
      //     [-10, -9, 1, 10, 11],
      //     [-20, -19, -18, -10, -9, -8, 1, 2, 10, 11, 12, 20, 21, 22],
      //     [-30, -29, -28, -27, -20, -19, -18, -17, -10, -9, -8, -7, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33]
      //   ],
      //   p2: []
      // };
      const markers = [];
      // const markerWidth = Math.round((30 / cols) * 10) / 10 + 'vw';
      const totalMarkers = 10;
      const halfOfMarkers = totalMarkers/2;
      let activePlayer;
      let activeMarker;
      let z; //active marker index
      const maxMoves = 3;
      let moveCount = 0;
      const allowedMoves = {
        p1: [
          [-cols, -cols+1, 1, cols, cols+1],
          [-cols*2, -cols*2+1, -cols*2+2, -cols, -cols+1, -cols+2, 1, 2, cols, cols+1, cols+2, cols*2, cols*2+1, cols*2+2],
          [-cols*3, -cols*3+1, -cols*3+2, -cols*3+3, -cols*2, -cols*2+1, -cols*2+2, -cols*2+3, -cols, -cols+1, -cols+2, -cols+3, 1, 2, 3, cols, cols+1, cols+2, cols+3, cols*2, cols*2+1, cols*2+2, cols*2+3, cols*3, cols*3+1, cols*3+2, cols*3+3]
        ],
        p2: []
      };
      for (i = 0; i < maxMoves; i++) {
        let _p2 = allowedMoves.p1[i].map(e => e * -1);
        allowedMoves.p2.push(_p2);
      }
      const points = {
        p1: 0,
        p2: 0
      };

      //create grid cells and add event listener for mouse click... clickCell() function
      let j = 0;
      let k = 0;
      const cellWidth = Math.round((grid.clientWidth - 110) / cols) + 'px';
      for (i = 0; i < cells; i++) {
        let cell = document.createElement('div');
        cell.style.width = cellWidth;
        cell.style.height = cellWidth;
        // cell.className = homeCells.indexOf(i) < 0 ? 'cell other' : 'cell home';
        cell.className = 'cell';
        if (firstCols.indexOf(i) > 0) {
          j++;
          k = 0;
        }
        // cell.className = 'cell ' + cellTypes[bugs[j]][k];
        cell.textContent = cellTypes[bugs[j]][k];
        // cell.setAttribute('data-celltype', cellTypes[bugs[j]][k]);
        cell.setAttribute('data-celltype', uniqueCellTypes.indexOf(cellTypes[bugs[j]][k]));
        cell.id = i;
        grid.appendChild(cell);
        k++;
      }

      //create markers
      const markerWidth = Math.round(((grid.clientWidth - 110) / cols) / 2) + 'px';
      for (i = 0; i < totalMarkers; i++) {
        let token = document.createElement('div');
        token.style.width = markerWidth;
        token.style.height = markerWidth;
        token.className = 'token';
        let colour = i < halfOfMarkers ? 'rgb(255, 118, 0)' : 'rgb(0, 108, 255)';
        let targets = i < halfOfMarkers ?  homeCells.slice(rows, rows*2) : homeCells.slice(0, rows);
        token.style.backgroundColor = colour;
        token.id = 'm' + i;
        //initial (home) position of each marker
        let homeCell = homeCells[i];
        let cell = document.getElementById(homeCell);
        let x = cell.offsetLeft + Math.round(cell.offsetWidth / 4);
        let y = cell.offsetTop + Math.round(cell.offsetHeight / 4);
        token.style.left = x + 'px';
        token.style.top = y + 'px';
        //make marker clickable and add to grid
        token.style.cursor = 'pointer';
        token.addEventListener('click', clickMarker);
        grid.appendChild(token);
        let markerObject = {marker:token, currentCell:homeCell, prevCell:homeCell, tokenColour:colour, targetCells:targets};
        markers.push(markerObject);
      }

      //remove click events from all cells (when clicking on marker and after moving marker)
      function removeCellClickEvent() {
        for (i = 0; i < cells; i++) {
          let cell = document.getElementById(i);
          cell.removeEventListener('click', clickCell);
          cell.style.cursor = 'default';
          // cell.style.backgroundColor = homeCells.indexOf(i) < 0 ? 'rgb(230, 230, 230)' : 'rgb(200, 200, 200)';
          cell.style.backgroundColor = 'rgb(230, 230, 230)';
        }
      }

      //add click event to required cells when clicking on marker
      function clickMarker(e) {
        activeMarker = e.target;
        if (activePlayer != undefined) {
          let prevActiveMarker = markers[z].marker;
          if (prevActiveMarker.style.backgroundColor == 'rgb(0, 0, 0)') {
            removeCellClickEvent();
            prevActiveMarker.style.backgroundColor = markers[z].tokenColour;
          }
          z = Number(activeMarker.id.charAt(1));
        } else {
          z = Number(activeMarker.id.charAt(1));
          if (z < halfOfMarkers) {
            activePlayer = 1;
            for (i = halfOfMarkers; i < totalMarkers; i++) {
              let token = document.getElementById('m' + i);
              token.removeEventListener('click', clickMarker);
              token.style.cursor = 'default';
            }
          } else {
            activePlayer = 2;
            for (i = 0; i < halfOfMarkers; i++) {
              let token = document.getElementById('m' + i);
              token.removeEventListener('click', clickMarker);
              token.style.cursor = 'default';
            }
          }
          document.getElementById('activePlayer').textContent = activePlayer;
          document.getElementById('moves').textContent = maxMoves;
        }
        activeMarker.style.backgroundColor = 'rgb(0, 0, 0)';
        let m = (maxMoves - moveCount) - 1;
        let moves = allowedMoves['p' + activePlayer][m];
        let movesLength = moves.length;

        let currentCellType = document.getElementById(markers[z].currentCell).getAttribute('data-celltype');
        for (i = 0; i < movesLength; i++) {
          let cellID = moves[i] + markers[z].currentCell;
          if (cellID >= 0 && cellID < cells && occupiedCells.indexOf(cellID) < 0) {
            let cell = document.getElementById(cellID);
            let nextCellType = cell.getAttribute('data-celltype');
            if ((moves[i] > -4 && moves[i] < 4) || currentCellType == nextCellType) {
              cell.style.backgroundColor = 'rgb(244, 244, 244)';
              cell.style.cursor = 'pointer';
              cell.addEventListener('click', clickCell);
            }
          }
        }
      }

      //move marker by clicking an empty cell (after clicking a marker)
      function clickCell(e) {
        removeCellClickEvent();
        let clickedCell = e.target;
        let cellA = markers[z].currentCell;
        markers[z].prevCell = cellA;
        let cellB = Number(clickedCell.id);
        markers[z].currentCell = cellB;
        let targetX = clickedCell.offsetLeft + Math.round(clickedCell.offsetWidth / 4);
        let targetY = clickedCell.offsetTop + Math.round(clickedCell.offsetHeight / 4);
        let mm = null;
        let x = activeMarker.offsetLeft;
        let y = activeMarker.offsetTop;
        let xDiff = (targetX - x) / 30;
        let yDiff = (targetY - y) / 30;
        clearInterval(mm);
        mm = setInterval(frame, 10);
        let i = 0;
        function frame() {
          if (i == 30) {
            clearInterval(mm);
            if (moveCount === 3) {
              swapPlayers();
            };
          } else {
            i++;
            x = x + xDiff;
            y = y + yDiff;
            activeMarker.style.left = x + 'px';
            activeMarker.style.top = y + 'px';
          }
        }
        activeMarker.style.backgroundColor = markers[z].tokenColour;
        occupiedCells.splice(occupiedCells.indexOf(cellA), 1, cellB);
        //check if clicked cell is a home cell (and add points if so)
        // if (homeCells.indexOf(cellB) >= 0) {
        //check if clicked cell is a target cell (and add points if so)
        if (markers[z].targetCells.indexOf(cellB) >= 0) {
          let updatedPoints = ++points['p' + activePlayer];
          document.getElementById('p' + activePlayer + 'Points').textContent = updatedPoints;
        }
        //calculate number of moves it takes to get to clicked cell
        let cellDiff = Math.abs(cellB - cellA);
        let newMoves = null;
        if (cellDiff % cols === 0) {
          newMoves = cellDiff / cols;
        } else {
          cellA = cellA % cols;
          cellB = cellB % cols;
          newMoves = Math.abs(cellB - cellA);
        }
        moveCount = moveCount + newMoves;
        document.getElementById('moves').textContent = maxMoves - moveCount;
      }

      function swapPlayers() {
        if (activePlayer === 1) {
          for (i = 0; i < totalMarkers; i++) {
            let token = document.getElementById('m' + i);
            if (i < halfOfMarkers) {
              token.removeEventListener('click', clickMarker);
              token.style.cursor = 'default';
            } else {
              token.addEventListener('click', clickMarker);
              token.style.cursor = 'pointer';
            }
          }
          activePlayer = 2;
        } else {
          for (i = 0; i < totalMarkers; i++) {
            let token = document.getElementById('m' + i);
            if (i < halfOfMarkers) {
              token.addEventListener('click', clickMarker);
              token.style.cursor = 'pointer';
            } else {
              token.removeEventListener('click', clickMarker);
              token.style.cursor = 'default';
            }
          }
          activePlayer = 1;
        }
        document.getElementById('activePlayer').textContent = activePlayer;
        moveCount = 0;
        document.getElementById('moves').textContent = maxMoves;
      }

      //reset game
      // function resetGame() {
      //   for (i = 0; i < cells; i++) {
      //     let cell = document.getElementById(i);
      //     cell.style.backgroundColor = 'rgb(230, 230, 230)';
      //     cell.onmouseover = function() {cell.style.boxShadow = '1px 1px 5px rgb(160, 160, 160)'};
      //     cell.onmouseout = function() {cell.style.boxShadow = 'initial'};
      //     cell.addEventListener('click', clickCell);
      //     cell.style.cursor = 'pointer';
      //   }
      // }

    </script>

  </body>

</html>
